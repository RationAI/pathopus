# WebGL in OpenSeadragon
Performs the visualisation rendering. It is a custom plugin to OpenSeadragon that takes a JSON describing the visualisation and handles the rendering using WebGL 2.0 or 1.0 (fallback). It is highly customizable and allows for multiple contexts in use.
In fact, you can even use this module (except the bridge class obviously) for any suitable purpose, without employing the OpenSeadragon library.

You can run multiple visualisations on multiple canvasses, each can have multiple visualisation goals (what shaders-layers are drawn with what data); and each goal can define arbitrary amount of layers to render
into its associated canvas, using highly customizable shaders (downloadable from custom sources). These layers can be manually re-ordered, changed and further parametrized by the user in the real time. For more information on dynamic shaders, see `./shaders/README.md`.

An example of valid parametrization (object passed to the constructor of `OpenSeadragonGL` which simply forwards it to `WebGLWrapper`):
//TODO

An example of valid visualisation goal (object(s) passed to `addVisualisation()`)


````JSON
{    
      "name": "A visualisation setup 1",
      "params": {
            "unique_id": "my_custom_webgl_engine"
      }, 
      "shaderSources" : [
            {
                   "url": "http://my-shader-url.com/customShader.js",
                   "headers": {},
                   "typedef": "new_type"
            }
      ],
      "shaders": {
            "path/to/probability/layer.tif": {
                   "name": "Probability layer",
                   "type": "color", 
                   "visible": "1", 
                   "params": { 
                      "color": "#fa0058"
                   }
            }
      }
}
````


### webGLToOSDBridge.js
Binding of WebGLWrapper to OpenSeadragon. The API is docummented in the code. A recommended use is:
```js
var seaGL = new OpenSeadragonGL({...});
var osd = new OpenSeadragon({...}); //init OSD without specifying the TileSources to load - delay the initialization

//load shaders now
seaGL.loadShaders(function() {
    //fire OpenSeadragon initialization after WebGLWrapper finished and the rendering can begin
    osd.open(...);
});
seaGL.init(osd); //calls seaGL.loadShaders(...) if not performed manually
```

### webGLWrapper.js
Wrapper for WebGL, handles all the visualiser-specific functionality, uses GlContextFactory to obtain an instance (GlContext) that renders the data.

### webGLContext.js
Includes GlContextFactory definition and its default subclass that implements `getContext()` and returns either `WebGL20` or `WebGL10` that behave as a `State` pattern, providing either WebGL 2.0 (if supported) or WebGL 1.0 (fallback) functionality respectively.

### Parameters of OpenSeadragonGL
You can create a new instance of the visualisation rendering using
```js
var visualiser = new OpenSeadragonGL({
    ...parameters...
});
```
These parameters will be given to WebGLWrapper and can customize the behaviour. Recognized and used parameters are

- `htmlControlsId`: REQUIRED, id of a HTML element to fill with visualisation controls
- `~~authorization~~` : value for the 'Authorization' header: e.g. `"Basic" + btoa("username:password")`
- `glContextFactory`: an instance, a subclass of `GlContextFactory` that can provide the visualiser with desired WebGL rendering functionality 

- `htmlShaderPartHeader()`: a function that defines the visualisation controls design
    - params: `title` title of the visualisation layer, `html` html controls generated by given shader part, `dataId`: data identifier (e.g. path to the tif), `isVisible` true if the layer is visible, `layer` the layer object itself, `isControllable` true if the user should be able to interact with the layer (e.g. no problems with the layer occured)
    - returns HTML that is going to be appended to a node with id `htmlControlsId` 
- `gl_loaded()`: a function called when a WebGL program is going to be loaded, you can implement this function, note that `jsGlLoadedCall` parameter is the name of a function this function should call for the program in use
    - params: `gl` WebGL context, `program` WebGLProgram instance
- `gl_drawing()`: a function called when a WebGL program is going to be used, you can implement this function, note that `jsGlDrawingCall` parameter is the name of a function this function should call for the program in use
    - params: `gl` WebGL context, `tile` <img> instance, image that contains the data to draw, `e` OpenSeadragon event associated with this event (see https://openseadragon.github.io/docs/OpenSeadragon.Viewer.html#.event:tile-drawing)
    - returns: `boolean` true if the data should be rendered using WebGL
- `ready()`: a function called once the OpenSeadragonGL is ready (fully initialized)
- `visualisationReady()`: a function called once a visualisation goal is ready (downloaded & compiled), called only on a succesfull initialization, note: JSON allows for multiple visualisation goals
    - params: `i` index of the visualisation goal, `visualisation` object holding all the visualisation data (both JSON initialization and output of `shaderGenerator` script and other initialization results performed by the wrapper)
    - TODO: create a class for visualisation object?
- `visualisationInUse()`: a function called when a certain visualisation is going to be used (e.g. user switches to a different vis goal)
    - params: `visualisation` object holding all the visualisation data
- `onFatalError()`: a function called when a certain visualisation goal is unable to run (e.g. shader compilation fails)
    - params: `visualisation` object holding all the visualisation data; this object has `error` and `desc` member variables (and can miss other normaly pressent ones)
- `onError()`: a function called when an unknown error occurs, but the visualisation is somewhat able to cope with it
    - params: `error` object that has `message`  member variable
